/* cwatch.c
 * Monitor file system activity using the inotify linux kernel library
 *
 * Copyright (C) 2012, Giuseppe Leone <joebew42@gmail.com>,
 *                     Vincenzo Di Cicco <enzodicicco@gmail.com>
 *
 * This file is part of cwatch
 *
 * cwatch is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * cwatch is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 *
 */

#include "cwatch.h"

/* Command line long options */
static struct option long_options[] =
{
    /* Options that set flags */
    
    /*
     {"verbose",       no_argument, &verbose_flag, TRUE},
     {"log",           no_argument, &syslog_flag,  TRUE},
    */
    
    /* Options that set index */
    {"command",       required_argument, 0, 'c'},
    {"directory",     required_argument, 0, 'd'},
    {"events",        required_argument, 0, 'e'},
    {"all",           no_argument,       0, 'a'},
    {"recursive",     no_argument,       0, 'r'},
    {"verbose",       no_argument,       0, 'v'},
    {"syslog",        no_argument,       0, 'l'},
    {"version",       no_argument,       0, 'V'},
    {"help",          no_argument,       0, 'h'},
    {0, 0, 0, 0}
};

/*
 * The inotify events LUT
 * for a complete reference of all events, look here:
 * http://tomoyo.sourceforge.jp/cgi-bin/lxr/source/include/uapi/linux/inotify.h
 */
static struct event_t events_lut[] =
{
    {"access",        event_handler_undefined},  /* IN_ACCESS */
    {"modify",        event_handler_undefined},  /* IN_MODIFY */
    {"attrib",        event_handler_undefined},  /* IN_ATTRIB */
    {"close_write",   event_handler_undefined},  /* IN_CLOSE_WRITE */
    {"close_nowrite", event_handler_undefined},  /* IN_CLOSE_NOWRITE */
    {"open",          event_handler_undefined},  /* IN_OPEN */
    {"moved_from",    event_handler_moved_from}, /* IN_MOVED_FROM */
    {"moved_to",      event_handler_moved_to},   /* IN_MOVED_TO */
    {"create",        event_handler_create},     /* IN_CREATE */
    {"delete",        event_handler_delete},     /* IN_DELETE */
    {"delete_self",   event_handler_undefined},  /* IN_DELETE_SELF */
    {"move_self",     event_handler_undefined},  /* IN_MOVE_SELF */
    {NULL,            event_handler_undefined},
    {"umount",        event_handler_undefined},  /* IN_UMOUNT */
    {"q_overflow",    event_handler_undefined},  /* IN_Q_OVERFLOW */
    {"ignored",       event_handler_undefined},  /* IN_IGNORED */
    {NULL,            event_handler_undefined},
    {NULL,            event_handler_undefined},
    {NULL,            event_handler_undefined},
    {NULL,            event_handler_undefined},
    {NULL,            event_handler_undefined},
    {NULL,            event_handler_undefined},
    {NULL,            event_handler_undefined},
    {NULL,            event_handler_undefined},
    {"onlydir",       event_handler_undefined},  /* IN_ONLYDIR */
    {"dont_follow",   event_handler_undefined},  /* IN_DONT_FOLLOW */
    {"excl_unlink",   event_handler_undefined},  /* IN_EXCL_UNLINK */
    {NULL,            event_handler_undefined},
    {NULL,            event_handler_undefined},
    {"mask_add",      event_handler_undefined},  /* IN_MASK_ADD */
    {"isdir",         event_handler_undefined},  /* IN_ISDIR */
    {"oneshot",       event_handler_undefined},  /* IN_ONESHOT */
    
    /* threated as edge cases (see get_inotify_event implementation) */
    {"close",         event_handler_undefined},  /* 32. IN_CLOSE */
    {"move",          event_handler_undefined},  /* 33. IN_MOVE */
    {"all_events",    event_handler_undefined},  /* 34. IN_ALL_EVENTS */
    
};

void print_version()
{
    printf("%s %s (%s)\n"
           "License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>\n"
           "This is free software: you are free to change and redistribute it.\n"
           "There is NO WARRANTY, to the extent permitted by law.\n",
           PROGRAM_NAME, PROGRAM_VERSION, PROGRAM_STAGE);
}

void help()
{
    printf("Usage: %1$s -c COMMAND -d DIRECTORY [-e event,[event,[,..]]] [-v] [-l]\n"
           "Usage: %1$s [-V|--version]\n"
           "Usage: %1$s [-h|--help]\n\n"
           "  -c --command COMMAND\n"
           "     The command to execute when an event occurs.\n"
           "     It is possibile to pass to the command special arguments generated by cwatch:\n"
           "       %2$sr : full path of the root DIRECTORY\n"
           "       %2$sp : full path of the file/directory where the event occurs\n"
           "       %2$sf : full path of the file/directory that triggered the event\n"
           "       %2$se : the type of the occured event (the the list below)\n\n"
           "  -d  --directory DIRECTORY\n"
           "      The directory to monitor\n\n"
           "  -e  --events [event,[event,[,..]]]\n"
           "      Specify which type of events to monitor. List of events:\n"
           "        access           : File was modified\n"
           "        modify           : File was modified\n"
           "        attrib           : File attributes changed\n"
           "        close_write      : File closed, after being opened in writeable mode\n"
           "        close_nowrite    : File closed, after being opened in read-only mode\n"
           "        close            : File closed, regardless of read/write mode\n"
           "        open             : File was opened\n"
           "        moved_from       : File was moved out of watched directory.\n"
           "        moved_to         : File was moved into watched directory.\n"
           "        move             : A file/dir within watched directory was moved\n"
           "        create           : A file was created within watched directory\n"
           "        delete           : A file was deleted within watched directory\n"
           "        delete_self      : The watched file was deleted\n"
           "        unmount          : File system on which watched file exists was unmounted\n"
           "        q_overflow       : Event queued overflowed\n"
           "        ignored          : File was ignored\n"
           "        isdir            : Event occurred against dir\n"
           "        oneshot          : Only send event once\n"
           "        all_events       : All events\n"
           "        default          : modify, create, delete, move.\n"
           "  -r  --recursive\n"
           "      Enable the recursively monitor of the directory\n\n"
           "  -a  --all\n"
           "      Enable the monitoring of hidden or temporary file (.dir or file~)\n\n"
           "  -v  --verbose\n"
           "      Verbose mode\n\n"
           "  -l  --syslog\n"
           "      Verbose mode through syslog\n\n"
           "  -h  --help\n"
           "      Output this help and exit\n\n"
           "  -V  --version\n"
           "      Out the version of the program and exit\n\n"
           ""
           "Reports bugs to: <https://github.com/joebew42/cwatch/issues/>\n"
           "%1$s home page: <https://github.com/joebew42/cwatch/>\n",
           PROGRAM_NAME, "%");
}

void log_message(char *message)
{
    if (verbose_flag)
        printf("%s\n", message);
    
    if (syslog_flag) {
        openlog(PROGRAM_NAME, LOG_PID, LOG_LOCAL1);
        syslog(LOG_INFO, message);
        closelog();
    }
    
    free(message);
}

void print_list(LIST *list_wd)
{
    LIST_NODE *node = list_wd->first;
    while (node) {
        WD_DATA *wd_data = (WD_DATA *) node->data;
        printf("%s, WD:%d, LNK:%d\n", wd_data->path, wd_data->wd, wd_data->symbolic_link);
        
        /* print the content of links list */
        if (wd_data->symbolic_link == TRUE) {
            LIST_NODE *n_node = wd_data->links->first;
            printf ("\tList of links that point to this path:\n");
            
            while (n_node) {
                char *p = (char*) n_node->data;
                printf("\t\t%s\n", p);
                n_node = n_node->next;
            }
        }
        node = node->next;
    }
}

char *resolve_real_path(const char *path)
{
    char *resolved = malloc(MAXPATHLEN + 1);
    
    realpath(path, resolved);
    
    if (resolved == NULL)
        return NULL;
    
    strcat(resolved, "/");
     
    return resolved;
}

LIST_NODE *get_from_path(const char *path)
{
    LIST_NODE *node = list_wd->first;
    while (node) {
        WD_DATA *wd_data = (WD_DATA *) node->data;
        if (strcmp(path, wd_data->path) == 0)
            return node;
        node = node->next;
    }
    
    return NULL;
}

LIST_NODE *get_from_wd(const int wd)
{
    LIST_NODE *node = list_wd->first;
    while (node) {
        WD_DATA *wd_data = (WD_DATA *) node->data;
        if (wd == wd_data->wd)
            return node;
        node = node->next;    
    }
    
    return NULL;
}

int parse_command_line(int argc, char *argv[])
{
    if (argc == 1) {
        help();
        exit(1);
    }
    
    /* Handle command line options */
    int c;
    int option_index = 0;
    while ((c = getopt_long(argc, argv, "lvraVhe:c:d:", long_options, &option_index)) != -1) {
        switch (c) {
        case 'c': /* --command */
            if (optarg == NULL || strcmp(optarg, "") == 0) {
                help();
                exit(1);
            }
                
            /* Store the command */
            command = malloc(strlen(optarg) + 1);
            strcpy(command, optarg);
                
            scommand = str_split(optarg, NULL);
            if (scommand == NULL) {
                printf("Unable to process the specified command!\n");
                exit(1);
            }
            
            break;

        case 'd': /* --directory */
            if (optarg == NULL || strcmp(optarg, "") == 0) {
                help();
                exit(1);
            }
            
            /* Check if the path has the ending slash */
            if (optarg[strlen(optarg)-1] != '/') {
                root_path = (char *) malloc(strlen(optarg) + 2);
                strcpy(root_path, optarg);
                strcat(root_path, "/");
            } else {
                root_path = (char *) malloc(strlen(optarg) + 1);
                strcpy(root_path, optarg);
            }
            
            /* Check if it is a valid directory */
            DIR *dir = opendir(root_path);
            if (dir == NULL) {
                help();
                exit(1);
            }
            closedir(dir);
            
            /* Check if the path is absolute or not */
            if( root_path[0] != '/' ) {
                char *real_path = resolve_real_path(root_path);
                free(root_path);
                root_path = real_path;
            }
            
            break;
        
        case 'e': /* --events */
            /* Set inotify events mask */
            sevents = str_split(optarg, ",");
            if (sevents != NULL) {
                int i;
                for (i = 0; i < sevents->size - 1; ++i) {
                    if (strcmp(sevents->substring[i], "access") == 0) {
                        event_mask |= IN_ACCESS;
                    } else if (strcmp(sevents->substring[i], "modify") == 0) {
                        event_mask |= IN_MODIFY;
                    } else if (strcmp(sevents->substring[i], "attrib") == 0) {
                        event_mask |= IN_ATTRIB;
                    } else if (strcmp(sevents->substring[i], "close_write") == 0) {
                        event_mask |= IN_CLOSE_WRITE;
                    } else if (strcmp(sevents->substring[i], "close_nowrite") == 0) {
                        event_mask |= IN_CLOSE_NOWRITE;
                    } else if (strcmp(sevents->substring[i], "close") == 0) {
                        event_mask |= IN_CLOSE;
                    } else if (strcmp(sevents->substring[i], "open") == 0) {
                        event_mask |= IN_OPEN;
                    } else if (strcmp(sevents->substring[i], "moved_from") == 0) {
                        event_mask |= IN_MOVED_FROM;
                    } else if (strcmp(sevents->substring[i], "moved_to") == 0) {
                        event_mask |= IN_MOVED_TO;
                    } else if (strcmp(sevents->substring[i], "move") == 0) {
                        event_mask |= IN_MOVE;
                    } else if (strcmp(sevents->substring[i], "create") == 0) {
                        event_mask |= IN_CREATE;
                    } else if (strcmp(sevents->substring[i], "delete") == 0) {
                        event_mask |= IN_DELETE;
                    } else if (strcmp(sevents->substring[i], "delete_self") == 0) {
                        event_mask |= IN_DELETE_SELF;
                    } else if (strcmp(sevents->substring[i], "unmount") == 0) {
                        event_mask |= IN_UNMOUNT;
                    } else if (strcmp(sevents->substring[i], "q_overflow") == 0) {
                        event_mask |= IN_Q_OVERFLOW;
                    } else if (strcmp(sevents->substring[i], "ignored") == 0) {
                        event_mask |= IN_IGNORED;
                    } else if (strcmp(sevents->substring[i], "isdir") == 0) {
                        event_mask |= IN_ISDIR;
                    } else if (strcmp(sevents->substring[i], "oneshot") == 0) {
                        event_mask |= IN_ONESHOT;
                    } else if (strcmp(sevents->substring[i], "all_events") == 0) {
                        event_mask |= IN_ALL_EVENTS;
                    } else if (strcmp(sevents->substring[i], "default") == 0) {
                        event_mask |= IN_MODIFY | IN_CREATE | IN_DELETE | IN_MOVE;
                    } else {
                        help();
                        printf("\nSpecified event \"%s\" not exists! Please see the help.\n",
                               sevents->substring[i]);
                        exit(1);
                    }
                }
            }
            break;
            
        case 'v': /* --verbose */
            verbose_flag = TRUE;
            break;

        case 'r': /* --recursive */
            recursive_flag = TRUE;
            break;

        case 'a': /* --all */
            all_flag = TRUE;
            break;
            
        case 'l': /* --syslog */
            syslog_flag = TRUE;
            break;
            
        case 'V': /* --version */
            print_version();
            exit(1);
            
        case 'h': /* --help */
                
        default:
            help();
            exit(1);
        }
    }
    
    if (root_path == NULL || command == NULL) {
        help();
        exit(1);
    }

    if (event_mask == 0) {
        event_mask = IN_MODIFY | IN_CREATE | IN_DELETE | IN_MOVE;
    }
    
    return 0;
}

int watch(char *real_path, char *symlink)
{
    /* Add initial path to the watch list */
    LIST_NODE *node = add_to_watch_list(real_path, symlink);
    if (node == NULL)
        return -1;
    
    /* Temporary list to perform a BFS directory traversing */
    LIST *list = list_init();
    list_push(list, (void *) real_path);
    
    DIR *dir_stream;
    struct dirent *dir;
    
    while (list->first != NULL) {
        /* Directory to watch */
        char *p = (char*) list_pop(list);
        
        dir_stream = opendir(p);
        
        if (dir_stream == NULL) {
            printf("UNABLE TO OPEN DIRECTORY:\t\"%s\" -> %d\n", p, errno);
            exit(1);
        }
        
        /* Traverse directory */
        while ((dir = readdir(dir_stream))) {
            if ((dir->d_type == DT_DIR)
                && strcmp(dir->d_name, ".") != 0
                && strcmp(dir->d_name, "..") != 0)
            {
                /* Absolute path to watch */
                char *path_to_watch = (char *) malloc(strlen(p) + strlen(dir->d_name) + 2);
                strcpy(path_to_watch, p);
                strcat(path_to_watch, dir->d_name);
                strcat(path_to_watch, "/");
                
                /* Append to watched resources */
                add_to_watch_list(path_to_watch, NULL);
				                
                /* Continue directory traversing */
                if (recursive_flag == TRUE) {
                    list_push(list, (void*) path_to_watch);
                }
            } else if (dir->d_type == DT_LNK) {
                /* Resolve symbolic link */
                char *symlink = (char *) malloc(strlen(p) + strlen(dir->d_name) + 2);
                strcpy(symlink, p);
                strcat(symlink, dir->d_name);
                strcat(symlink, "/");
                
                char *real_path = resolve_real_path(symlink);
                
                if (real_path != NULL && opendir(real_path) != NULL) {
                    /* Append to watched resources */
                    add_to_watch_list(real_path, symlink);
                    
                    /* Continue directory traversing */
                    if (recursive_flag == TRUE) {
                        list_push(list, (void*) real_path);
                    }
                }
            }
        }
        closedir(dir_stream);
    }
    
    list_free(list);
    
    return 0;
}

LIST_NODE *add_to_watch_list(char *real_path, char *symlink)
{
    /* Check if the resource is already in the watch_list */
    LIST_NODE *node = get_from_path(real_path);
    
    /* If the resource is not watched yet, then add it into the watch_list */
    if (node == NULL) {
        /* Append directory to watch_list */
        int wd = inotify_add_watch(fd, real_path, event_mask);
        
        /* INFO Check limit in: /proc/sys/fs/inotify/max_user_watches */
        if (wd == -1) {
            printf("AN ERROR OCCURRED WHILE ADDING PATH %s:\n", real_path);
            printf("Please consider these possibilities:\n");
            printf(" - Max number of watched resources reached! See /proc/sys/fs/inotify/max_user_watches\n");
            printf(" - Resource is no more available!?\n");
            return NULL;
        }
        
        /* Create the entry */
        WD_DATA *wd_data = malloc(sizeof(WD_DATA));
        wd_data->wd = wd;
        wd_data->path = real_path;
        wd_data->links = list_init();
        wd_data->symbolic_link = (strncmp(root_path, real_path, strlen(root_path)) == 0) ? FALSE : TRUE;
        
        node = list_push(list_wd, (void*) wd_data);
        
        /* Log Message */
        char *message = (char *) malloc(MAXPATHLEN);
        sprintf(message, "WATCHING: (fd:%d,wd:%d)\t\t\"%s\"", fd, wd_data->wd, real_path);
        log_message(message);
    }

    /*
     * Check if the symbolic link (if any) is not been added before.
     * This control is necessary to avoid that cyclic links counts twice.
     */
    if (node != NULL && symlink != NULL) {
        WD_DATA *wd_data = (WD_DATA*) node->data;

        bool_t found = FALSE;
        LIST_NODE *node_link = wd_data->links->first;
        while (node_link) {
            char *link = (char *) node_link->data;
            if (strcmp(link, symlink) == 0) {
                found = TRUE;
                break;
            }
            
            node_link = node_link->next;
        }
        
        if (found == FALSE) {
            list_push(wd_data->links, (void *) symlink);
            /* Log Message */
            char *message = (char *) malloc(MAXPATHLEN);
            sprintf(message, "ADDED SYMBOLIC LINK:\t\t\"%s\" -> \"%s\"", symlink, real_path);
            log_message(message);
        }
    }
    
    return node;
}

void unwatch(char *path, bool_t is_link)
{
    /* Remove the resource from watched resources */
    if (is_link == FALSE) {
        /* Retrieve the watch descriptor from path */
        LIST_NODE *node = get_from_path(path);
        if (node != NULL) {   
            WD_DATA *wd_data = (WD_DATA *) node->data;
            
            /* Log Message */
            char *message = (char *) malloc(MAXPATHLEN);
            sprintf(message, "UNWATCHING: (fd:%d,wd:%d)\t\t%s", fd, wd_data->wd, path);
            log_message(message);
            
            inotify_rm_watch(fd, wd_data->wd);
            
            if (wd_data->links->first != NULL)
                list_free(wd_data->links);
            
            list_remove(list_wd, node);
        }
    } else {
        /* Remove a symbolic link from watched resources */
        LIST_NODE *node = list_wd->first;
        while (node) {
            WD_DATA *wd_data = (WD_DATA*) node->data;
            
            LIST_NODE *link_node = wd_data->links->first;
            while (link_node) {
                char *p = (char*) link_node->data;
                
                /* Symbolic link match. Remove it! */
                if (strcmp(path, p) == 0) {
                    /* Log Message */
                    char *message = (char *) malloc(MAXPATHLEN);
                    sprintf(message, "UNWATCHING SYMBOLIC LINK: \t\t%s -> %s", path, wd_data->path);
                    log_message(message);
                    
                    list_remove(wd_data->links, link_node);
                    
                    /*
                     * if there is no other symbolic links that point to the
                     * watched resource and the watched resource is not the root,
                     * then unwatch it
                     */
                    if (wd_data->links->first == NULL && wd_data->symbolic_link == TRUE) {
                        WD_DATA *sub_wd_data;
                        
                        /*
                         * Build temporary look-up list of resources
                         * that are pointed by some symbolic links.
                         */
                        LIST *tmp_linked_path = list_init();
                        LIST_NODE *sub_node = list_wd->first;
                        while (sub_node) {
                            sub_wd_data = (WD_DATA*) sub_node->data;
                            
                            /*
                             * If it is a PARENT or CHILD and it is referenced by some symbolic link
                             * and it is not listed into tmp_linked_path, then
                             * add it into the list and move to the next resource.
                             */
                            if ((strncmp(wd_data->path, sub_wd_data->path, strlen(wd_data->path)) == 0
                                || strncmp(wd_data->path, sub_wd_data->path, strlen(sub_wd_data->path)) == 0)
                                && sub_wd_data->links->first != NULL
                                && exists(sub_wd_data->path, tmp_linked_path) == 0)
                            {
                                /* Save current path into linked_path */
                                list_push(tmp_linked_path, (void*) sub_wd_data->path);
                            }
                            
                            /* Move to next resource */
                            sub_node = sub_node->next;
                        }
                        
                        /*
                         * Descend to all subdirectories of wd_data->path and unwatch them all
                         * only if they or it's parents are not pointed by some symbolic link, anymore
                         * (check if parent is not pointed by symlinks too).
                         */
                        sub_node = list_wd->first;
                        while (sub_node) {
                            sub_wd_data = (WD_DATA*) sub_node->data;
                                                        
                            /*
                             * If it is a CHILD and is NOT referenced by some symbolic link
                             * and it is not listed into tmp_linked_path, then
                             * remove the watch descriptor from the resource.
                             */
                            if (strcmp(root_path, sub_wd_data->path) != 0
                                && strncmp(wd_data->path, sub_wd_data->path, strlen(wd_data->path)) == 0
                                && sub_wd_data->links->first == NULL
                                && exists(sub_wd_data->path, tmp_linked_path) == 0)
                            {
                                /* Log Message */
                                char *message = (char *) malloc(MAXPATHLEN);
                                sprintf(message, "UNWATCHING: (fd:%d,wd:%d)\t\t%s", fd, sub_wd_data->wd, sub_wd_data->path);
                                log_message(message);
                                
                                inotify_rm_watch(fd, sub_wd_data->wd);
                                list_remove(list_wd, sub_node);
                            }
                            
                            /* Move to next resource */
                            sub_node = sub_node->next;
                        }
                        
                        /* Free temporay lookup list */
                        list_free(tmp_linked_path);
                    }
                    return;
                }
                link_node = link_node->next;
            }
            node = node->next;
        }
    }
}

int exists(char* child_path, LIST *parents)
{
    if (parents == NULL || parents->first == NULL)
        return 0;
    
    LIST_NODE *node = parents->first;
    while(node) {
        char* parent_path = (char*) node->data;
        // printf("Checking for: %s \t Possible parent: %s\n", child_path, parent_path);
        if (strlen(parent_path) <= strlen(child_path)
            && strncmp(parent_path, child_path, strlen(parent_path)) == 0)
        {
            return 1; /* match! */
        }
        node = node->next;
    }
    return 0;
}

int monitor()
{
    /* Buffer for File Descriptor */
    char buffer[EVENT_BUF_LEN];

    /* inotify_event */
    struct inotify_event *event = NULL;
    struct event_t *triggered_event = NULL;

    /* The real path of touched directory or file */
    char *path = NULL;
    size_t len;
    int i;
    
    /* Temporary node information */
    LIST_NODE *node = NULL;
    WD_DATA *wd_data = NULL;
    
    /* Wait for events */
    while ((len = read(fd, buffer, EVENT_BUF_LEN))) {
        if (len < 0) {
            printf("ERROR: UNABLE TO READ INOTIFY QUEUE EVENTS!!!\n");
            exit(1);
        }
        
        /* index of the event into file descriptor */
        i = 0;
        while (i < len) {
            /* inotify_event */
            event = (struct inotify_event*) &buffer[i];

            /* Discard hidden or temporary file is all_flag is FALSE */
            if (all_flag == FALSE
                && (event->name[0] == '.' || event->name[strlen(event->name)-1] == '~'))
            {
                /* Next event */
                i += EVENT_SIZE + event->len;
                continue;
            }
            
            /* Build the full path of the directory or symbolic link */
            node = get_from_wd(event->wd);
            if (node != NULL) {
                wd_data = (WD_DATA *) node->data;
                path = malloc(strlen(wd_data->path) + strlen(event->name) + 2);
                strcpy(path, wd_data->path);
                strcat(path, event->name);
                if (event->mask & IN_ISDIR)
                    strcat(path, "/");
            } else {
                /* Next event */
                i += EVENT_SIZE + event->len;
                continue;
            }
            
            /* Call the specific event handler */
            if (event->mask & event_mask
                && (triggered_event = get_inotify_event(event->mask & event_mask)) != NULL
                && triggered_event->name != NULL)
            {
                if (triggered_event->handler(event, path) == 0) {
                    if (execute_command(triggered_event->name, path, wd_data->path) == -1) {
                        printf("ERROR OCCURED: Unable to execute the specified command!\n");
                        exit(1);
                    }
                }
            }
            
            /* Next event */
            i += EVENT_SIZE + event->len;
        }
    }

    return 0;
}

STR_SPLIT_S *str_split(char *str, char *sep)
{
    if (str == NULL || strlen(str) == 0)
        return NULL;
    
    if (sep == NULL || strlen(sep) > 1) {
        sep = (char *) malloc(2);
        strcpy(sep, " ");
    }
    
    STR_SPLIT_S *r = (STR_SPLIT_S *) malloc(sizeof(STR_SPLIT_S));
    r->size = 2;

    /* count number of occurrences */
    int i = 0;
    while (str[i])
        if (str[i++] == *sep)
            ++r->size;

    r->substring = (char **) malloc(sizeof(char *) * r->size);
    
    /* find all occurrences */
    i = 0;
    r->substring[i] = strtok(str, sep);
    while (r->substring[i] != NULL)
        r->substring[++i] = strtok(NULL, sep);
    
    return r;
}

int execute_command(char *event_name, char *event_path, char *event_p_path)
{
    /* TODO maybe will be necessary to add a burst limit */
    
    /* For log purpose */
    char *message = (char *) malloc(MAXPATHLEN);
    
    /* Replace special pattern */
    char **command_to_execute = (char **) malloc(sizeof(char *) * scommand->size);
    
    int i;
    for (i = 0; i < scommand->size - 1; ++i) {
        if (strcmp(scommand->substring[i], COMMAND_PATTERN_ROOT) == 0) {
            command_to_execute[i] = root_path;
        } else if (strcmp(scommand->substring[i], COMMAND_PATTERN_PATH) == 0) {
            command_to_execute[i] = event_p_path;
        } else if (strcmp(scommand->substring[i], COMMAND_PATTERN_FILE) == 0) {
            command_to_execute[i] = event_path;
        } else if (strcmp(scommand->substring[i], COMMAND_PATTERN_EVENT) == 0) {
            command_to_execute[i] = event_name;
        } else {
            command_to_execute[i] = scommand->substring[i];
        }
    }
    command_to_execute[i] = NULL;
    
    /* Execute the command */
    pid_t pid = fork();
    if (pid > 0) {
        /* parent process */
        sprintf(message, "EVENT TRIGGERED [%s] %s\nPROCESS EXECUTED [pid: %d command: %s]",
                event_name, event_path, pid, command);
        log_message(message); 
    } else if (pid == 0) {
        /* child process */
        if (execvp(command_to_execute[0], command_to_execute) == -1) {
            sprintf(message, "Unable to execute the specified command!");
            log_message(message);
        }
    } else {
        /* error occured */
        sprintf(message, "ERROR during the fork() !!!");
        log_message(message);
        exit(1);
    }
    
    free(command_to_execute);
    
    return 0;
}

struct event_t *get_inotify_event(const uint32_t event_mask)
{
    switch (event_mask) {
    case IN_CLOSE:       return &events_lut[32];
    case IN_MOVE:        return &events_lut[33];
    case IN_ALL_EVENTS:  return &events_lut[34];
    default:             return &events_lut[ffs(event_mask)-1];
    }
}

/*
 * EVENT HANDLER IMPLEMENTATION
 */

int event_handler_undefined(struct inotify_event *event, char *path)
{
    return 0;
}

int event_handler_create(struct inotify_event *event, char *path)
{
    /* Return 0 if recurively monitoring is disabled */
    if (recursive_flag == FALSE)
        return 0;
    
    /* Check for a directory */
    if (event->mask & IN_ISDIR) {
        watch(path, NULL);
    } else {
        /* Check for a symbolic link */
        bool_t is_dir = FALSE;
        DIR *dir_stream = opendir(path);
        if (dir_stream != NULL)
            is_dir = TRUE;
        closedir(dir_stream);
                    
        if (is_dir == TRUE) {
            /* resolve symbolic link */
            char *real_path = resolve_real_path(path);
                        
            /* check if the real path is already monitored */
            LIST_NODE *node = get_from_path(real_path);
            if (node == NULL) {
                watch(real_path, path);
            } else {
                /* 
                 * Append the new symbolic link
                 * to the watched resource
                 */
                WD_DATA *wd_data = (WD_DATA *) node->data;
                list_push(wd_data->links, (void*) path);
                            
                /* Log Message */
                char *message = (char *) malloc(MAXPATHLEN);
                sprintf(message, "ADDED SYMBOLIC LINK:\t\t\"%s\" -> \"%s\"", path, real_path);
                log_message(message);
            }
        }
    }

    return 0;
}

int event_handler_delete(struct inotify_event *event, char *path)
{
    /* Check if it is a folder. If yes unwatch it */
    if (event->mask & IN_ISDIR) {
        unwatch(path, FALSE);
    } else {
        /*
         * XXX Since it is not possible to know if the
         *     inotify event belongs to a file or a symbolic link,
         *     the unwatch function will be called for each file.
         *     That is because the file is deleted from filesystem,
         *     so there is no way to stat it.
         *     This is a big computational issue to be treated.
         * TAI Try to opendir(path), if it will not NULL, then
         *     it is a link that point to a directory.
         */
        unwatch(path, TRUE);
    }

    return 0;
}

int event_handler_moved_from(struct inotify_event *event, char *path)
{
    return event_handler_delete(event, path);
}

int event_handler_moved_to(struct inotify_event *event, char *path)
{
    if (strncmp(path, root_path, strlen(root_path)) == 0)
        return event_handler_create(event, path);
    
    return 0; /* do nothing */
}
